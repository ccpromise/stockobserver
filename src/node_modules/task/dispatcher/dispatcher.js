
/**
 * dispatcher: manage all tasks status.
 * 1) receive newly produced tasks from producer
 * 2) dispatch ready tasks to consumer.
 * 3) receive execution results from consumer.
 * usage sample: node dispatcher.js
 */
const http = require('http');
const config = require('config');
const utility = require('utility');
const time = utility.time;
const async = utility.async;
const HttpPack = utility.HttpPack;
const HttpError = utility.error.HttpError;
const taskStatus = require('usrConstants').taskStatus;
const checkReadyCondition = require('condition/checkReadyCondition');
const httpHandlers = require('handlers');
const producer = require('producer');

/**
 * task collection
 */
const taskCol = httpHandlers.task.db.taskCol;

/**
 * all http handlers.
 */
const simulateHttp = httpHandlers.simulate.http;
const taskHttp = httpHandlers.task.http;
const tradeHttp = httpHandlers.trade.http;
const pathMap = {
    '/rtSimulate': simulateHttp.rtSimulate,
    '/simulate': simulateHttp.simulate,
    '/simdate': simulateHttp.simdate,
    '/task': taskHttp.task,
    '/trade': tradeHttp.tradeplan
}

/**
 * create server which receives http request from producer&consumer&task handlers
 */
function createServer() {
    var server = http.createServer((req, res) => {
        var httpPack = new HttpPack(req, res);
        var origin = httpPack.getReqHeader('origin');
        var method = httpPack.getReqHeader('Access-Control-Request-Method');
        var headers = httpPack.getReqHeader('Access-Control-Request-Headers');
        if(origin !== undefined) {
            httpPack.setResHeader('access-control-allow-origin', origin);
        }
        if(method !== undefined) {
            httpPack.setResHeader('access-control-allow-method', method);
            httpPack.setResHeader('access-control-allow-headers', headers);
            httpPack.status = 200;
            httpPack.send();
            return;
        }

        var path = httpPack.reqPath; // readonly
        if(!(path in pathMap)) {
            httpPack.resBody = 'path not found'; // write only
            httpPack.status = 404;
            httpPack.send();
            return;
        }
        httpPack.reqBody().then((body) => {
            // all http request body is json type
            var data = JSON.parse(body.toString());
            var handler = pathMap[path];
            var verb = httpPack.getReqHeader('verb');
            if(!handler.isValid(data, verb)) {
                return Promise.reject(new Error('invalid data and verb' + data + ' ' + verb));
            }
            return handler.run(data, verb).then((r) => {
                httpPack.resBody = r;
                httpPack.status = 200;
                httpPack.send();
            }).catch((err) => {
                httpPack.resBody = err.message;
                httpPack.status = err instanceof HttpError ? err.statusCode : 500;
                httpPack.send();
            })
        }).catch((err) => {
            httpPack.resBody = err.message;
            httpPack.status = 400;
            httpPack.send();
        })
    });
    server.listen(config.dispatcherPort);
    console.log('start to listen on ', config.dispatcherHost, ': ', config.dispatcherPort);
}

/**
 * remove timeout task from taskCol
 */
function removeTimeOutTask() {
    var loop = function() {
        setTimeout(() => {
            taskCol.update({
                'status': taskStatus.processing, 'lastProcessedTs': { $lt: time.getTs(time.now()) - config.maxTaskDuration }
            }, {
                $set: { 'status': taskStatus.ready },
                $push: { 'log': {
                    'desc': 'task time out',
                    'time': time.format(time.now()),
                    'err': new Error('task time out')
                }}
            }).catch((err) => {
                console.log('fail to remove task: ', err);
                process.exit();
            }).then(loop);
        }, config.checkTimeoutInterval);
    };
    loop();
}

/**
 * check waiting task if the ready condition has been satisfied.
 */
function checkWaitingTask() {
    var loop = function() {
        setTimeout(() => {
            taskCol.find({ status: taskStatus.wait }).then((docs) => {
                var i = 0;
                var N = docs.length;
                var readyTaskId = [];

                //* find waiting task whoes ready condtion is true
                return async.parallel(() => {
                    return i < N;
                }, () => {
                    var j = i++;
                    try {
                    var type = docs[j].readyCondition.type;
                    }
                    catch(err){
                        console.info(docs[j]);
                        throw err;
                    }
                    var pack = docs[j].readyCondition.pack;
                    return checkReadyCondition(type, pack).then((r) => {
                        if(r) readyTaskId.push(docs[j]._id);
                    });
                }, 10).then(() => { return readyTaskId; });
            }).then((readyTaskId) => {
                //* update status from wait to ready
                return readyTaskId.length === 0
                ? Promise.resolve()
                : taskCol.updateMany(readyTaskId.map((id) => {
                    return {
                        'filter': { _id: id },
                        'update': {
                            $set: { status: taskStatus.ready },
                            $push: { log: {
                                'desc': 'update waiting task to ready',
                                'time': time.format(time.now()),
                                'err': null
                            }}
                        }
                    }
                }));
            }).catch((err) => {
                console.log('fail to check waiting task: ', err);
                process.exit();
            }).then(loop);
        }, config.checkWaitingTaskInterval)
    };
    loop();
}

function run() {
    createServer();
    removeTimeOutTask();
    //checkWaitingTask();
    //producer.run();
};

run();
