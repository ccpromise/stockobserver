
const utility = require('utility')
const validate = utility.validate;
const object = utility.object;
const refReplace = utility.refReplace;
const time = utility.time;
const postReq = utility.httpPostRequest;
const makePvd = require('dataPvd');

exports.checkPack = function(args) {
    return validate.isObj(args) && object.numOfKeys(args) === 2 && validate.isStr(args.tradeplanId) && validate.isStr(args.secID);
}

exports.run = function(args) {
    var tradeplanId = args.tradeplanId;
    var secID = args.secID;
    var valueMap = { secID: secID };

    return postReq({ path: '/trade', data: { filter: { _id: tradeplanId } }, headers: { verb: 'findOne' } }).then((r) => {
        var plan = JSON.parse(r.toString());
        if(plan === null) return Promise.reject(new Error('invalid tradeplanId'));

        var dpInLiteral = refReplace(plan.dpInTmpl, valueMap);
        var dpOutLiteral = refReplace(plan.dpOutTmpl, valueMap);
        var dpIn = makePvd(dpInLiteral);
        var dpOut = makePvd(dpOutLiteral);
        var end = makePvd({ 'type': 'end', 'pack': secID });

        return Promise.all([dpIn, dpOut, end]).then((dpArr) => {
            var dpIn = dpArr[0], dpOut = dpArr[1], end = dpArr[2];

            return postReq({ path: '/simdate', data: { filter: { tradeplanId: tradeplanId, secID: secID } }, headers: { verb: 'findOne'} }).then((r) => {
                var doc = JSON.parse(r.toString());
                return doc === null ? null : doc.lastSimTs;
            }).then((lastSimTs) => { //* find if there are new in-trades since lastSimTs
                var startTs = lastSimTs === null ? dpIn.minTs : dpIn.forwardDateTs(lastSimTs, 1);

                if(startTs === -1) return [];
                return findBuyTs(startTs, dpIn).map((ts) => {
                    var price = end.get(ts);
                    return {
                        tradeplanId: tradeplanId,
                        secID: secID,
                        st: ts,
                        et: ts,
                        ht: ts,
                        lt: ts,
                        sp: price,
                        ep: price,
                        hp: price,
                        lp: price,
                        closed: false
                    }
                })
            }).then((newTrades) => { //* update all the open trades
                return postReq({ path: '/simulate', data: { filter: { 'tradeplanId': tradeplanId, 'secID': secID, 'closed': false } }, headers: { verb: 'find' } }).then((r) => {
                    var openTrades = JSON.parse(r.toString()).concat(newTrades);
                    var updatedTrades = updateOpenTrade(openTrades, dpOut, end);
                    var docs = updatedTrades.map((trade) => {
                        if(trade._id) // update
                            return {
                                filter: { _id: trade._id },
                                update: { $set: { et: trade.et, ht: trade.ht, lt: trade.lt, ep: trade.ep, hp: trade.hp, lp: trade.lp, closed: trade.closed } }
                            }
                        else { // insert
                            return {
                                filter: { tradeplanId: tradeplanId, secID: secID, st: trade.st},
                                update: { $set: { et: trade.et, ht: trade.ht, lt: trade.lt, sp: trade.sp, ep: trade.ep, hp: trade.hp, lp: trade.lp, closed:  trade.closed } }
                            }
                        }
                    });
                    return docs.length === 0 ? Promise.resolve() : postReq({ path: '/simulate', data: docs, headers: { verb: 'upsertMany' } });
                })
            }).then(() => { //* udpate lastSimTs
                return postReq({ path: '/simdate', data: { filter: { tradeplanId: tradeplanId, secID: secID }, update: { $set: { lastSimDate: dpIn.maxTs } } }, headers: { verb: 'upsert' } });
            });
        })
    })
}

function findBuyTs(startTs, dpIn) {
    var ts = startTs;
    var buyTs = [];

    while(ts !== -1) {
        if(dpIn.get(ts)) buyTs.push(ts);
        ts = dpIn.forwardDateTs(ts, 1);
    }
    return buyTs;
}

function updateOpenTrade(tradeArr, dpOut, end) {
    tradeArr.forEach((trade) => {
        var ts = dpOut.forwardDateTs(trade.et, 1);
        while(ts !== -1) {
            var price = end.get(ts);
            trade.ep = price;
            trade.et = ts;
            if(price > trade.hp) {
                trade.hp = price;
                trade.ht = ts;
            }
            if(price < trade.lp) {
                trade.lp = price;
                trade.lt = ts;
            }
            if(dpOut.get(ts)) {
                trade.closed = true;
                break;
            }
            ts = dpOut.forwardDateTs(ts, 1);
        }
    });
    return tradeArr;
}
